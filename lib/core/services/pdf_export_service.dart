import 'dart:io';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:path_provider/path_provider.dart';
import 'package:ttrpg_sim/core/database/database.dart';

class PdfExportService {
  Future<File> generatePdf(String bookText, CharacterData char) async {
    final pdf = pw.Document();

    pdf.addPage(
      pw.Page(
        build: (pw.Context context) {
          return pw.Center(
            child: pw.Column(
              mainAxisAlignment: pw.MainAxisAlignment.center,
              children: [
                pw.Text('The Chronicles of ${char.name}',
                    style: pw.TextStyle(
                        fontSize: 40, fontWeight: pw.FontWeight.bold)),
                pw.SizedBox(height: 20),
                pw.Text('A LitRPG Adventure',
                    style: pw.TextStyle(
                        fontSize: 24, fontStyle: pw.FontStyle.italic)),
                pw.SizedBox(height: 10),
                pw.Text('Generated by AI Game Master',
                    style: const pw.TextStyle(fontSize: 18)),
              ],
            ),
          );
        },
      ),
    );

    // Parse the book text for Markdown-like blue box blocks
    // Format is:
    // > **SYSTEM**
    // > [Content]

    final lines = bookText.split('\n');
    List<pw.Widget> contentWidgets = [];

    bool insideBlueBox = false;
    List<String> blueBoxLines = [];

    void flushBlueBox() {
      if (blueBoxLines.isNotEmpty) {
        contentWidgets.add(pw.Container(
          padding: const pw.EdgeInsets.all(10),
          margin: const pw.EdgeInsets.symmetric(vertical: 5),
          decoration: pw.BoxDecoration(
            color: PdfColors.blue50,
            border: pw.Border.all(color: PdfColors.blue, width: 2),
            borderRadius: const pw.BorderRadius.all(pw.Radius.circular(4)),
          ),
          child: pw.Column(
              crossAxisAlignment: pw.CrossAxisAlignment.start,
              children: blueBoxLines
                  .map((l) => pw.Text(l,
                      style: pw.TextStyle(
                          color: PdfColors.blue800, font: pw.Font.courier())))
                  .toList()),
        ));
        blueBoxLines.clear();
      }
    }

    // Standard markdown parser is too heavy for simple requirement, so manual parse
    for (var line in lines) {
      if (line.trim().startsWith('>')) {
        if (!insideBlueBox) {
          // Check if it's the start of a system block
          if (line.contains('**SYSTEM**')) {
            insideBlueBox = true;
            continue; // Skip the header line
          }
        }
        // It is a block line, strip the >
        final cleanLine = line.replaceAll('>', '').trim();
        if (insideBlueBox) {
          blueBoxLines.add(cleanLine);
        } else {
          // Just a normal quote block? Treat as text for now
          contentWidgets.add(pw.Text(cleanLine,
              style: pw.TextStyle(fontStyle: pw.FontStyle.italic)));
        }
      } else {
        if (insideBlueBox) {
          flushBlueBox();
          insideBlueBox = false;
        }
        if (line.trim().isNotEmpty) {
          // Basic formatting
          if (line.startsWith('CHAPTER')) {
            contentWidgets.add(pw.Header(
                level: 1,
                text: line,
                textStyle: pw.TextStyle(
                    fontSize: 24, fontWeight: pw.FontWeight.bold)));
          } else if (line.trim() == '---') {
            contentWidgets.add(pw.Divider());
          } else {
            contentWidgets.add(pw.Paragraph(text: line));
          }
        }
      }
    }
    // Flush if ended on blue box
    if (insideBlueBox) flushBlueBox();

    pdf.addPage(
      pw.MultiPage(
        build: (context) => contentWidgets,
      ),
    );

    final output = await getApplicationDocumentsDirectory();
    final file = File(
        "${output.path}/litrpg_story_${char.id}_${DateTime.now().millisecondsSinceEpoch}.pdf");
    await file.writeAsBytes(await pdf.save());
    return file;
  }
}
